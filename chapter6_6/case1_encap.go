package chapter6_6

import (
	"fmt"
	"time"
)

// Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。
// 这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。
// 这也就是前面的小节中IntSet被定义为struct类型的原因，尽管它只有一个字段:
type IntSet struct {
	words []uint64
}

// 如果将IntSet定义为slice类型
type IntSet2 []uint64

// 尽管这个版本的IntSet在本质上是一样的，但它也允许其它包中可以直接读取并编辑这个slice。
// 例如: var x IntSet定义一个变量,如果不使用struct的方式,使用*x就可以访问这个切片,而如果使用struct类型,那么小写words(切片)则不会被外界直接访问!!
// 这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的"类型"。

// 封装的优点
// 1.调用方无需理解全部实现
// 2.隐藏细节,增加实现时的灵活性
// 3.避免调用方任意修改内部值

// Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证API兼容的情况下去除对其的导出.
// 所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。

// 封装并不总是理想的。 虽然封装在有些情况是必要的，但有时候我们也需要暴露一些内部内容，
// 比如：time.Duration将其表现暴露为一个int64数字的纳秒，使得我们可以用一般的数值操作来对时间进行对比，甚至可以定义这种类型的常量：
func Encap() {
	const day = 24 * time.Hour
	fmt.Println(day.Seconds()) // "86400"
}

// 另一个例子，将IntSet和本章开头的geometry.Path进行对比。Path被定义为一个slice类型，这允许其调用slice的字面方法来对其内部的points用range进行迭代遍历；在这一点上，IntSet是没有办法让你这么做的。
// 这两种类型决定性的不同：geometry.Path的本质是一个坐标点的序列，不多也不少，我们可以预见到之后也并不会给他增加额外的字段，所以在geometry包中将Path暴露为一个slice。
// 相比之下，IntSet仅仅是在这里用了一个[]uint64的slice。这个类型还可以用[]uint类型来表示，或者我们甚至可以用其它完全不同的占用更小内存空间的东西来表示这个集合，所以我们可能还会需要额外的字段来在这个类型中记录元素的个数。也正是因为这些原因，我们让IntSet对调用方不透明。

// 尽管方法对于OOP编程来说至关重要，但他们只是OOP编程里的半边天。为了完成OOP，我们还需要接口。Go里的接口会在下一章中介绍。
