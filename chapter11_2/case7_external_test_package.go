package chapter11_2

// 考虑下这两个包：net/url包，提供了URL解析的功能；net/http包，提供了web服务和HTTP客户端的功能。
// 如我们所料，上层的net/http包依赖下层的net/url包。然后，net/url包中的一个测试是演示不同URL和HTTP客户端的交互行为。
// 也就是说，一个下层包的测试代码导入了上层的包。
// 这样的行为在net/url包的测试代码中会导致包的循环依赖，Go语言规范是禁止包的循环依赖的。

// 不过我们可以通过外部测试包的方式解决循环依赖的问题，也就是在net/url包所在的目录声明一个独立的url_test测试包。
// 其中包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。
// 我们将这个外部测试包的导入路径视作是net/url_test会更容易理解，但实际上它并不能被其他任何包导入。
// 因为外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包；包内的测试代码就无法做到这点。
// 在设计层面，外部测试包是在所有它依赖的包的上层。
// 通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。

// 我们可以用go list命令查看包对应目录中哪些Go源文件是产品代码，哪些是包内测试，还有哪些是外部测试包。
// 我们以fmt包作为一个例子：GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分。
// $ go list -f {{.GoFiles}} fmt
// [doc.go format.go print.go scan.go]

// TestGoFiles表示的是fmt包内部测试代码，以_test.go为后缀文件名，不过只在测试时被构建：
// $ go list -f {{.TestGoFiles}} fmt
// [export_test.go]
